+++
title = "What do you want to make the computer do?"
date = "2023-02-15"
draft = true

#
# description is optional
#
# description = "An optional description for SEO. If not provided, an automatically created summary will be used."

tags = ["Thoughts"]
+++

Over the last few months I have been digging into Rust (the programming language) and the more I use it the more time I want to invest in it.
This is not a post about Rust but rather the thought process on getting started with a new programming language (or multiple languages) in a world where these languages are driving technologies like cloud services, blockchains and artificial intelligence.
We live in a time where the frontier of modern technology is looking to solve problems that no longer appear to be solvable by a single person, so in learning a new language we are presented with a spectrum of opportunities that lie somewhere between programming "hello-world" and a distributed blockchain.
When learning a programming language, there comes a time when you have to eventually program.
In doing so it is important to choose a task/project that is within the realm of possibility so as to not dishearten and hinder learning progress, but also provide a sense of accomplishment that programming another version of grep simply will not provide.

In an attempt to find an interesting project to build in order to learn Rust, I decided to google around for some ideas.
I cannot recall where, but one commenter suggested that instead of trying to find a project, rather ask yourself:

What do you want to make the computer do?

This can be seen as obvious advice, but it struck me as rather profound.
Having programmed for years, I honestly cannot think of a time when I thought "What do I want to make the computer do".
I would imagine that I am not alone in feeling this way.
In our daily work-lives we are assigned all sorts of tasks to instruct the computer to do impressive things:
* Serve an interactive website to the world over a port using a secure protocol.
* Move data from this database to that SFTP server using a serverless event-driven architecture.
* Learn mathematical parameters from this dataset and use them in an equation to predict some future behaviour.

All of which are posed to us as a problem to solve given a certain set of tools, a hyperthetical set of building blocks that we can piece together to achieve the predefined goal.
I think the value underlying the advice of "What do you want to make the computer do?" is two fold:

1. Have you ever thought what you want to make the computer do? Not what someone else wants it to do or thinks it should do.
2. With the packages and modules available in most programming language ecosystems, spinning up a webserver or training a machine learning model is often so trivial (think Flask/Scikit-Learn) that one could argue that your effort in making the computer do something is fairly insignificant, you were just along for the ride.

My argument is therefore: 

1. Program something that you want to make the computer do that serves only you and not some peer-pressured agenda based on the current hype.
Instead of building another grep or a multithreaded webserver.
Find a problem/area of interest in our life that you believe could be solved by a programme within your grasp and attempt to make it.
It doesn't matter if there is a package out there that does what you want, that is not the point.
Just build it, publish it and enjoy it.

2. Try no-dependancy learning (within reason).

You are never going to learn multithreaded programming by using a package that does it for you, nor are you going to find any fulfillment in importing that package to do so.

It is the resistance to learning that makes it fulfilling and forces you out of your comfort zone, where true learning takes place.
Of course, these are just my opinions but I would love to hear if the statement resonates with you too and if you have found fulfillment in learning this way.

Happy building!"
